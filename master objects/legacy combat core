@prog $rpg_room:_combat"Allow up to 5 rounds of inactivity before killing the combat task.";if (caller != this)  return E_PERM;endifroundc = 0;active = 3;while (sorted = `this:sort_combatants() ! E_VERBNF')  this:announce_to_combatants(tostr("A new round (", roundc = roundc + 1, ") begins"));  active = this:do_combat_round(sorted, active);  if (`this:round_wait() ! E_VERBNF' == E_VERBNF)    return;  endifendwhile`this.combat_task = 0 ! E_PROPNF';.@prog $rpg_room:kill_combat":kill_combat()";"Clear the combatants list and kill the current combat task.";if (!$code_utils:task_valid(id = this.combat_task))  return E_NONE;endif"Clear the `attacking' list of everyone involved, then clear combatants.";for c in (this.combatants)  `c.attacking = {} ! E_PROPNF';endforthis:announce_to_combatants("The battle ends");this.combatants = {};return kill_task(id);.@prog $rpg_room:Do_combat_round":do_combat(sorted-combatants, max-idle-rounds)";"Loop through the given list of combatants, allowing each of them to :act.";"Kill combat if nothing happens and max-idle-rounds is one, else decrement that number and return it.";{sorted, active} = args;if (!this:is_controllable_by(caller_perms(), caller))  return E_PERM;endifaction = 0;for who in (sorted)  points = `who:act() ! E_VERBNF => 0';  if (points)    action = 1;    try      this:turn_wait();    except (E_VERBNF)      return;    endtry  endifendforfor who in (sorted)  `who:cleanup() ! E_VERBNF';endforif ((active = action ? active | active - 1) < 1)  this:kill_combat();endifreturn active;.