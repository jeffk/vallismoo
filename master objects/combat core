attack.hands = 1/2 (required hands to attack)attack:can_attack(player,target)attack:do_attack()attack.speed = 1-100 (how long it takes to complete attack)attack.damage = 1-100 (base damage for attack)weapon.damage = 1-100 (extra damage for attack [weight])player:get_strength() = 1-100 (extra damage for attack [power])weapon.attacks = list of attacksweapon.parry_mod = 1-100 (how useful weapon is in parrying)attack sequence:player:attack -player:get_weapon(*weapon)  -player:hands_used() -weapon:get_attack()   -weapon:get_body_group(target) -room:do_attack(type,attacker,target,weapon,attack,body_group)   -room:can_attack(type,attacker,target,weapon,attack,body_group)   -room:resolve_attack(type,target,player,attack,weapon,body_group)     -player:attack_roll(attack,weapon)       -room:attack_mods(type,target,player,attack,weapon,body_group)         -room:get_light_mod(player)         -room:get_size_mod(player,target)     -target:defense_mod(type,player,attack,weapon,body_group)       -room:defense_mod(type,target,player,attack,weapon,body_group)   -room:recieve_damage(type,attacker,target,weapon,damage,damage type,body_group)     -target:recieve_damage(type,attacker,target,weapon,damage,damage type,body_group)       -target:knockout(type,attacker,target,weapon,damage,damage type,body_group)       -target:die(type,attacker,target,weapon,damage,damage type,body_group)         -player:karma_mod(player,target)     -attack:get_fatigue(player,attacker)       -player:recieve_fatigue()possible attack commands:kill serpent's headkill serpent with axekill serpent's head with axe$combatant:handshands = pass(@args);hands = length(hands);for weapon in (player:wielding())  hands = hands - weapon.required_hands;endforreturn(hands);@prog $combatant:flee"flee [<direction>]";"flee             -- Flee in any direction.  Quicker.";"flee <direction> -- Flee in the given direction.";if (callers() && !this:is_controllable_by(caller_perms(), caller))  return E_PERM;endifwhere = this.location;if (!args)  this:maybe_queue_action("flee anywhere", "flee", {}, 30 - (this:get_stat(#305)/3));elseif (valid(exit = where:match_exit(dobjstr)))  this:maybe_queue_action("flee " + exit:name(), "flee", {exit}, 50 - (this:get_stat(#305)/3));elseif (exit == $ambiguous_match)  all = $match_utils:match_list(dobjstr, where:obvious_exits());  player:tell("You'll have to choose between ", $string_utils:name_list(all), ", or just 'flee' to run like Hell.");else  player:tell("You can't go that way.  (", dobjstr, ")");endif.$combatant:kill"kill object";"kill object's bodyarea";"kill object's bodyarea with weapon";if (callers() && !this:is_controllable_by(caller_perms(), caller))  return E_PERM;endifif (iobjstr == "")  weapon = this:get_weapon();else  weapon = this:get_weapon(iobjstr);endifthis.current_weapon = weapon;target = this:get_target(dobjstr);if (!$object_utils:isa(weapon,$weapon))  player:tell("You don't seem to be able to attack with ",iobjstr,".");  return;elseif(!target[1])  player:tell("You don't seem to be able to find ",dobjstr,".");  return;endifthis:queue_action(verb + " " + dobjstr,"attack",{target[2],weapon},1);this:add_attacker(dobj);@verb $combatant:"add_attacker" this none this "RX" $gamemaster@prog $combatant:add_attacker":add_attacker(who)";"Add `who' as a character in combat with this one.";if (!this:is_controllable_by(caller_perms()))  return E_PERM;endifwho = args[1];this.location:add_combatant(this, who);return this.attacking = setadd(this.attacking, who);.$combatant:do_attack(target,weapon)"Do our permission checking, and run our attack!";tar = args[1];target = tar[1];area = 0;if (tar[2] != E_RANGE)  area = tar[2];endifweapon = args[2];if (this.current_weapon != weapon)  player:tell("You don't seem to be wielding ",weapon.name," anymore.  Attack canceled.");  return;endifperm = (this:room()):can_attack(this,target,weapon,area);if (perm)  weapon:do_attack(this,target,weapon,area);else  return(0);endif@verb $room:can_attack(attacker,target,weapon,area);":can_attack(attacker,target,weapon,body_area);";"Just a general permission check to see if they can do it.";return(1);@verb $combatant:"get_target" this none this "RXD" me@prog $combatant:get_target":get_target(str)";"{1, {targ}}          -> Success.";"{1, {targ, area}}    -> Success and body area for called shot.";"{0, {targ, area_str}}    -> Found target, but not body area.";"{0, {str}}               -> Failure.";"{0, {str, {@ambigs}}     -> Failure due to given ambiguous matches.";s = args[1];p = $match_utils:parse_possessive_ref(s);if (p)  s = p[1];  a = p[2];else  a = "";endife = this:possible_targets();m = this:my_match_object(s, e);if (m == $ambiguous_match)  m = $match_utils:match_list(s, e);  if (!m)    return {0, {s}};  elseif (this:get_option($combat_options, "first_ord"))    m = m[1];  else    return {0, {s, m}};  endifelseif (!valid(m))  return {0, {s}};endifif (!a)  return {1, {m}};elseif (!valid(b = `m:match_body_area(a, 1) ! ANY => #-1'))  return {0, {m, a}};else  return {1, {m, b}};endif.@prog $combatant:wieldingreturn(this.wielding);.@prog $combatant:get_weapon"$combatant:get_weapon(\"weapon name\");";"Returns the referenced weapon, or a current weapon, a random wielded weapon, or a current natural weapon if that weapon can't be found.";this:cleanup_wielding();if (args[1] == E_RANGE)  if (this.current_weapon == #-1)    if (length(this.wielding) == 0)      weapon = this:get_natural_weapon();    else      weapon = this.wielding[random(length(this.wielding))];    endif  elseif ((this.current_weapon):location() != player)    if (length(this.wielding) == 0)      weapon = this:get_natural_weapon();    else      weapon = this.wielding[random(length(this.wielding))];    endif  else    weapon = this.current_weapon;  endifelse  wep = args[1];  if (typeof(this.natural_weapon) == LIST)    weaponlist = {@this.contents,@this.natural_weapon};  else    weaponlist = {@this.contents,this.natural_weapon};  endif  weapon = this:match_object(wep,weaponlist);endifreturn(weapon); @prog $combatant:cleanup_wieldingfor weapon in (this.wielding)  if (weapon:location() != this)    this.weilding = setremove(this.wielding,weapon);  endifendfor.  @prog $weapon:locationreturn(this.location);.@prog $natural_weapon:locationreturn(player);.@prog $combatant:get_natural_weaponif (typeof(this.natural_weapon) == LIST)  return(this.natural_weapon[random(length(this.natural_weapon))]);else  return(this.natural_weapon);endif.@prog $combatant:possible_targets":possible_targets()";e = {};RPG = $rpg;loc = this:room();if (0)  for c in (loc:env())    if (RPG:is_character(c) && RPG:is_attackable(c))      e = {@e, c};    endif  endforelse  e = loc:env();endiffor x in (loc:exits())  if (typeof(l = x:blocked_by(this)) == LIST)    e = {@e, @l};  endifendforreturn e;.@prog $rpg:is_attackable"Returns whether or not the arg can be attacked.";if (args[1].density < 3)  return(1);else  return(0);endif@verb $combatant:act this none this "RX" #2@prog $combatant:act":act() -- Do the first action inthe queue.";"The action will be called with player and caller_perms() of this object.";"-> NUM Action points expended.";if (!this:is_controllable_by(caller_perms(), caller))  return E_PERM;elseif (this:death_pending())  return E_NACC;elseif (unc = this:unconscious())  "Will heal unconsciousness down to 1, minimum.  No valid reason.";  if (unc > 1)    this.unconscious = this.unconscious - 1;  endif  this.queue = {};  return 0;endifq = this.queue;if (!q)  return 0;endifaction = q[1];"----- This should perhaps be moved into each :do_* verb -----";ok = this:attempt_action(action[3], action[4]);if (typeof(ok) != NUM)  this:remove_action(1);  return 0;endif"-----";this.pending_actions = {@this.pending_actions, action};this:remove_action(1);fork (0)  if (this:unconscious() || this:death_pending())    return 0;  endif  player = this;  dobj = iobj = $nothing;  this:my_call_verb(action[2], "do_" + action[3], action[4]);endforkreturn action[5];.@verb $combatant:"queue_action" this none this "RXD" #2@prog $combatant:queue_action":queue_action(what, action, args, slowness)";"Add the given action, printing messages for any errors which might occur.";"Return the position of the new action if successful, false otherwise.";if (!this:attempt_queue(@args))  return;endifset_task_perms(cp = caller_perms());action = args[2];result = this:add_action(@args);if (typeof(result) == NUM)  this:tell("Action \"", args[1], "\" (", result, ") queued.");elseif (result == E_PERM)  cp:tell("Permission denied to add action ", $string_utils:print(args), " to queue of ", $string_utils:nn(this), ".");  this:tell("Action \"", args[1], "\" NOT queued: ", result);elseif (result == E_NACC)  this:tell("Action \"", args[1], "\" not permitted in this area.");else  this:tell("Action \"", args[1], "\" NOT queued: ", result);endifreturn result;.@verb $combatant:"add_action" this none this "RXD" $gamemaster@prog $combatant:add_action":add_action(STR what, STR|LIST action, LIST args, NUM slowness)";"-- Add the given action to the queue.";"what       - String describing the action.";"action     - Verbname to call, or list of {object, verbname}.";"args       - Args to verbcall.";"slowness   - Time required for the attack.";"-> NUM length of new queue.";"-> E_PERM if illegal caller or obj is specified and not owned by caller.";"-> E_NACC if the action is not permitted.";"If a custom object is given as element one in 'action', the calling permissions MUST control it for it to be added to the queue.";cp = caller_perms();if (!this:is_controllable_by(cp, caller))  return E_PERM;elseif (!(q = this.queue))  this.slowness = args[4];endifspec = args[2];if (typeof(spec) != LIST)  action = listinsert(args, this, 2);elseif (0 && !spec[1]:is_writable_by(cp))  return E_PERM;else  action = {args[1], @spec, args[3], args[4]};endifif ($rpg:is_rushed_task())  this.queue = {action, @q};  total = 1;  $rpg:delete_rushed_task();else  total = length(this.queue = {@q, action});endifwhere = this.location;where:add_combatant(this);where:birth_combat();return total;.@verb $combatant:"remove_action" this none this "RXD" $gamemaster@prog $combatant:remove_action":remove_action(NUM n) -- Remove the action indexed by `n' from the queue.";"-> NUM length of new queue.";if (!this:is_controllable_by(caller_perms(), caller))  return E_PERM;elseif (!(q = this.queue))  return E_NONE;endifq = listdelete(q, args[1]);this.slowness = q ? q[1][5] | 0;return length(this.queue = q);.@verb $combatant:"attempt_queue" this none this "RXD" $gamemaster@prog $combatant:attempt_queue":attempt_queue(@queue_args)";"Attempt to queue an action described by the given args.  Return false if that action should not be allowed to be queued.  Such a case usually results when the character is 'busy', as when e is ambushing someone.";"Messages should be printed if the queue is not to be allowed.";if (a = this.ambushing)  this:tell("You are lying in ambush, waiting for ", $english:indef_art(a), " \"", a, "\", and thus cannot queue any actions.  To stop ambushing, type `stop ambushing`.");elseif (this:queue_length() >= (m = $rpg.max_queue_length))  this:tell("The system allows a maximum of ", m, " actions to be queued. You'll have to wait for them those you have (`actions`) to fire, or cancel some (`cancel <#>`).");else  return 1;endifreturn 0;.@verb $combatant:"queue_length" this none this "RXD" $gamemaster@prog $combatant:queue_length":queue_length()";"Return the total number of actions in this combatant's queue.";return length(this.queue);.$combatant:do_defend(attacker,target,weapon,attack,body_area)$room:attack_mod(attacker,target,weapon,attack,body_area)$combatant:damage_mods(rating,stat)rating = args[1];stat = args[2];injury = this.injury;fatigue = this.fatigue;drain = this.drain;ttl = 0;for type in (stat.effected_by)  dam = this.(type);  if (dam > 0)    if (type == "injury")      mod = 0.5;    else      mod = 1.0;    endif    if ((dam > 0) && (dam <= 20))      ttl = ttl + tonum(tofloat(dam) / (10.0 * mod));    elseif ((dam > 20) && (dam <= 40))      ttl = ttl + tonum(tofloat(dam) / (8.0 * mod));    elseif ((dam > 40) && (dam <= 60))      ttl = ttl + tonum(tofloat(dam) / (6.0 * mod));    elseif ((dam > 60) && (dam <= 80))      ttl = ttl + tonum(tofloat(dam) / (4.0 * mod));    elseif ((dam > 80))      ttl = ttl + tonum(tofloat(dam) / (2.0 * mod));    endif  endifendforreturn(ttl*-1);