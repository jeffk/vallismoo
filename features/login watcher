It is with much apprehension I introduce the GhostMOO Login Watcher.  This is currently for the Wiz staff only, although the code isn't limited to them at this point.  Anybody can use the code, but only $wizzes, $progs, and $geos can see players that are hidden connect and disconnect.  The FO is #2691, and if people don't scream, I'd like to be able to introduce it to the MOO public tommorow.After you've added the FO, the options are thus:@watch player / @watch allThe first incarnation will show you the connections/disconnections of a specific player, or add it to your list of watched players.  The second incarnation will wipe your watched list, and show you everybody that logs in/out.@unwatch player / @unwatch allWipes that player, or everyone from your watched list.  This is for when the spam gets to be too much, and you're being notified by a bunch of people you don't care about.@watcher-optionsSelf explanitory.  It works just like @options-bleah.  Toggles login and logout notification.------------------------@watch any none nonetarget = $match_utils:match_player(argstr);if (((target == #-3) || (target == #-1) || (target == #-2)) && (dobjstr != "all") && (dobjstr != "none") && (dobjstr != "nobody"))  player:tell("Player match failed!");  return;endifcounter = 1;if ((argstr == "none") || (argstr == "nobody"))  for entry in (this.watchers)    if (entry[1] == player)      this.watchers[counter][2] = {};      return player:tell("You are now not watching anyone!  Good for you, you're on the bright and shiny road to recovery and non-spamdom.");    endif    counter = counter + 1;  endfor  return;endifcounter = 1;if (argstr == "all")  for entry in (this.watchers)    if (entry[1] == player)      this.watchers[counter][2] = {"all"};      return player:tell("You are now watching everyone!  You paranoid FREAK.");    endif    counter = counter + 1;  endfor  this.watchers = $list_utils:append(this.watchers,{{player,{"all"},1}});  return player:tell("You are now watching everyone!  You paranoid FREAK.");endifcounter = 1;for entry in (this.watchers)  if (entry[1] == player)    db = entry[2];    db = setadd(db,target);    this.watchers[counter][2] = db;    player:tell("Target ",target.name, " (",target,") added to watched list.");    return;  endif  counter = counter + 1;endforthis.watchers = $list_utils:append(this.watchers,{{player,{target},1}});player:tell(tostr("Target ",target.name, " (",target,") added to watched list."));@unwatch any none nonetarget = $match_utils:match_player(argstr);if ((target == #-3) && (argstr != "all"))  return player:tell("Player match failed!");endifcounter = 1;if (argstr == "all")  for entry in (this.watchers)    if (entry[1] == player)      this.watchers[counter][2] = {};      return player:tell("You are now not watching anyone!  Good for you, you're on the bright and shiny road to recovery and non-spamdom.");    endif    counter = counter + 1;  endforendifcounter = 1;for entry in (this.watchers)  if (entry[1] == player)    db = entry[2];    db = setremove(db,target);    this.watchers[counter][2] = db;    player:tell("Target ",target.name, " (",target,") removed from watched list.");    return;  endif  counter = counter + 1;endforplayer:tell("You aren't watching that person!");@watched none none nonefor entry in (this.watchers)  if (entry[1] == player)    if (entry[2] == {})      player:tell("You aren't currently watching anybody.");      return;    endif    if (entry[2][1] != "all")      player:tell("You are currently watching ",$string_utils:iname_list(entry[2]),".");    else      player:tell("You are currently watching everyone.");    endif    return;  endifendforplayer:Tell("You aren't currently watching anybody.");@options-loginwatcher any any anyrecord = {};for entry in (this.watchers)  if (entry[1] == player)    record = entry;  endifendforif (record == {})  player:tell("You are currently not a Login Watcher user.");  return;endifif (dobjstr == "")    player:tell("    Current Login Watcher Options:");    if (record[3] == 0)      player:tell("-logouts       Logouts are not shown.");      player:tell("-logins        Logins are not shown.");    elseif (record[3] == 1)      player:tell("+logouts       Logouts are shown.");      player:tell("+logins        Logins are shown.");    elseif (record[3] == 2)      player:tell("+logouts       Logouts are shown.");      player:tell("-logins        Logins are not shown.");    elseif (record[3] == 3)      player:tell("-logouts       Logouts are not shown.");      player:tell("+logins        Logins are shown.");    endifelseif (dobjstr[1] == "+")  if (dobjstr[2..$] == "logins")    if (record[3] == 0)      record[3] = 3;    elseif (record[3] == 2)      record[3] = 1;    endif  else    if (record[3] == 0)      record[3] = 2;    elseif (record[3] == 3)      record[3] = 1;    endif  endifelseif (dobjstr[1] == "-")  if (dobjstr[2..$] == "logins")    if (record[3] == 1)      record[3] = 2;    elseif (record[3] == 3)      record[3] = 0;    endif  else    if (record[3] == 1)      record[3] = 3;    elseif (record[3] == 2)      record[3] = 0;    endif  endifendifcounter = 1;for entry in (this.watchers)  if (entry[1] == player)    this.watchers[counter] = record;    return player:tell("Done.");  endif  counter = counter + 1;endfor$loginwatcher:loopthis:watchlogins();this.core:add_queue(this,"loop",5);$loginwatcher:watchloginssuspend(0);starttime = ticks_left();olddb = this.db;newdb = connected_players();this.db = newdb;newplayers = newdb;oldplayers = olddb;if (newplayers == oldplayers)  endtime = ticks_left();  list = this.timecodes[2..12];  this.timecodes = $list_utils:flatten({list,starttime-endtime});  return;endiffor plyr in (olddb)  newplayers = setremove(newplayers,plyr);endforfor plyr in (newdb)  oldplayers = setremove(oldplayers,plyr);endforfor entry in (this.watchers)  if ($list_utils:count(entry[1],connected_players()))    notifylist = {};    notifylist2 = {};    if (entry[2] != {})      if (entry[2][1] == "all")          notifylist = newplayers;          notifylist2 = oldplayers;      else        for plyr in (newplayers)          if ($list_utils:count(plyr, entry[2]))            notifylist = {notifylist, plyr};          endif        endfor        for plyr in (oldplayers)          if ($list_utils:count(plyr, entry[2]))            notifylist2 = {notifylist2, plyr};          endif        endfor      endif    endif    notifylist = $list_utils:flatten(notifylist);    notifylist2 = $list_utils:flatten(notifylist2);      if (!$rpg:trusted(entry[1]))          for booger in (notifylist)            if (booger:get_option($privacy_options, "hide_who"))              notifylist = setremove(notifylist,booger);            endif          endfor          for booger in (notifylist2)            if (booger:get_option($privacy_options, "hide_who"))              notifylist2 = setremove(notifylist2,booger);            endif          endfor      endif    if ((notifylist != {}) && (entry[3] != 0) && (entry[3] != 2))      if (length(notifylist) == 1)        entry[1]:tell("[Login] ",$string_utils:name_list(notifylist)," has connected.");      else        entry[1]:tell("[Login] ",$string_utils:name_list(notifylist)," have connected.");      endif    elseif ((notifylist2 != {}) && (entry[3] != 0) && (entry[3] != 3))      if (length(notifylist2) == 1)        entry[1]:tell("[Logout] ",$string_utils:name_list(notifylist2)," has disconnected.");      else        entry[1]:tell("[Logout] ",$string_utils:name_list(notifylist2)," have disconnected.");      endif    endif  endifendforendtime = ticks_left();list = this.timecodes[2..12];this.timecodes = $list_utils:flatten({list,starttime-endtime});@set #2691.timecodes to {11, 1474, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11}@showtickstotal = 0;for entry in (this.timecodes)  total = total + entry;endforplayer:tell(tostr("Last 12 tick counts total ",$string_utils:english_list(this.timecodes),".  Total tick count for last minute is ", total,"."));Verb: #2691:watchlogins Time: 1253 ticks.One user notified, two users logged in.Verb: #2691:watchlogins Time: 777 ticks.None notified, two users logged in.Verb: #709:@who Time: 8155 ticks.Advanced WHO.Verb: #709:who Time: 1938 ticks.Local who, one user.Verb: #709:WHO Time: 4663 ticks.WHO with 7 users.To put this in perspective, a new process begins with 50,000 ticks to its name, and can be replenished with ;suspend();For more perspective, a full @daudit of myself takes...Verb: #1010:@daudit Time: 31147 ticks.Mulder sat at the bar idly, rapping his knuckles on its beer stained surface.  After the other nights tedious confrontation, he didn't want to risk another run-in with the terrible trio.  But how would he know when they logged in?  He wasn't in the habit of typing 'WHO' every few seconds...  What could he do?  "By jove," he exclaimed, "I could write a login watcher!"Osbornn eyed him warily, "A what?"Mulder grinned, "A login watcher... you know, that watches for logins, and when they happen, tells you about em!""Ah, I see," Osbornn replied, "But what are you going to do about lag?  And how are you going to get a Spice Girls lyric into this post?""Well, about the lag..." Mulder said slowly, and then grinned, "We've got something kinda funny going on.  We've got something kinda funny going on...  Wherever you're going, high or low, remember to sure enjoy the show, so climb aboard my journey deep inside, better late than dead on time.""What's that got to do with lag," Osbornn coughed."Well, nothing really.  Except maybe the 'better late than dead on time' part.  Which is why I created a little widget to monitor how much CPU time this login watcher's taking.""Oh, well, that's good.  Wouldn't want it to get out of hand.""Indeed," Mulder said with a grin, "But Ylise, Smoke, and Lamia all just logged in, so I've got to be moseying along."-------------- Insert nitty gritty details here --------------Most of you should know what a login watcher does, but if you don't, here's the low down.  You tell it who you want to watch for, and it does just that.  If it spots them, then it tells you.  Simple enough.  Easier than watching the WHO listing.The commands work thusly:@watch <person> / @watch allThe first version only watches for specific people, while the second tells you about everybody.  (Read: SPAM)@unwatch <person> / @unwatch allRemoves a specific person, or everyone, from your watch listing.@watcher-optionsShows a list of options related to the login watcher.  Works just like the @options-mail and such commands.  This one controls whether you're shown logins, logouts, or both.@timecodesThis shows the tick counts for the main watcher verb over the last minute.  The verb runs in five second intervals, which are appended to the end of the listing.  If this command shows things are getting out of hand (15,000 tick counts listed repeatedly over a minutes time) we'll have to reconsider the login watcher, and it may be pulled.********* Privacy *********The login watcher does not show hidden users logins or logouts.  If you don't want people to know your here (aside from wizzen), then @hide.FYI, there is also a @watched command, which shows you who you are currently watching.  The Login Watcher is a FO, and to have it, you must @add-feature #2691.