"Setup our targets.";targets = $string_utils:explode(argstr);obja = player:my_match_object(dobjstr);objb = player:my_match_object(iobjstr);if (obja == #-3)  player:tell("First object match failed on ",dobjstr,".");  return;elseif (objb == #-3)  player:tell("Second object match failed on ",iobjstr,".");  return;endif"Now find the common ancestor.";parenta = obja;parentb = objb;parentsa = {obja};if (verbs(obja) != E_PERM)  verbsa = {verbs(obja)};else  verbsa = {{}};endifparentsb = {objb};if (verbs(objb) != E_PERM)  verbsb = {verbs(objb)};else  verbsb = {{}};endifif (properties(obja) != E_PERM)  propsa = {properties(obja)};else  propsa = {{}};endifif (properties(objb) != E_PERM)  propsb = {properties(objb)};else  propsb = {{}};endifswitch = 1;while (switch)  $command_utils:suspend_if_needed(1);  parenta = parent(parenta);  if ((parenta == #1) || (parenta == #-1))    switch = 0;  endif  parentsa = {parentsa, {parenta}};  if (verbs(parenta) != E_PERM)    verbsa = {@verbsa, {verbs(parenta)}};  else    verbsa = {@verbsa,{}};  endif  if (properties(parenta) != E_PERM)    propsa = {@propsa, {properties(parenta)}};  else    propsa = {@propsa,{}};  endifendwhileswitch = 1;while (switch)  $command_utils:suspend_if_needed(1);  parentb = parent(parentb);  if ((parentb == #1) || (parentb == #-1))    switch = 0;  endif  parentsb = {parentsb, {parentb}};  if (verbs(parentb) != E_PERM)    verbsb = {@verbsb, {verbs(parentb)}};  else    verbsb = {@verbsb,{}};  endif  if (properties(parentb) != E_PERM)    propsb = {@propsb, {properties(parentb)}};  else    propsb = {@propsb,{}};  endifendwhileparentsa = $list_utils:flatten(parentsa);parentsb = $list_utils:flatten(parentsb);"Ok, we _should_ have two seperate sets of properties, with all the necessary info in em.";common = 1;commona = 0;commonb = 0;for parent in (parentsa)  $command_utils:suspend_if_needed(1);  commona = commona + 1;  for kid in (parentsb)    commonb = commonb + 1;    if (parent == kid)      if (common == 1)        common = parent;        cntra = commona;      endif    endif  endforendforcntrb = 1;switch = 1;for parent in (parentsb)  if (parent == common)    if (cntrb == 1)      cntrb = switch;    endif  endif  switch = switch + 1;endforif (common == 1)  player:tell("Ack, no common parents!");  return;else  player:tell("Common parent: ",common.name," (",common,")");endifverbsa = verbsa[1..cntra-1];verbsb = verbsb[1..cntrb-1];parentsa = parentsa[1..cntra-1];parentsb = parentsb[1..cntrb-1];propsa = propsa[1..cntra-1];propsb = propsb[1..cntrb-1];player:tell("First Parents: ",length(parentsa)," with ",length($list_utils:flatten(verbsa))," verbs, and ",length($list_utils:flatten(propsa))," properties.");player:tell("Second Parents: ",length(parentsb), " with ",length($list_utils:flatten(verbsb))," verbs, and ",length($list_utils:flatten(propsb))," properties.");counter = 1;for parenta in (parentsa)  if (verbsa[counter] != E_PERM)    for verba in (verbsa[counter])      counterb = 1;      for parentb in (parentsb)        if (verbsb[counter] != {})          for verbb in (verbsb[counter])            $command_utils:suspend_if_needed(1);            if (this:match_verb(verba,verbb))              player:tell("Verb conflict: ",parenta.name," (",parenta,"):",verba," with ",parentb.name," (",parentb,").");            endif          endfor        endif        counterb = counterb + 1;      endfor    endfor  endifendforfor parenta in (parentsa)  if (propsa[counter] != {})    for propa in (propsa[counter])      counterb = 1;      for parentb in (parentsb)        if (propsb[counter] != {})          for propb in (propsb[counter])            $command_utils:suspend_if_needed(1);            if (propa == propb)              player:tell("Property conflict: ",parenta.name," (",parenta,").",propa," with ",parentb.name," (",parentb,").");            endif          endfor        endif        counterb = counterb + 1;      endfor    endfor  endifendfor